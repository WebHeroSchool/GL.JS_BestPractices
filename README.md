# Лучшие и давно устоявшиеся практики

## 1. Размещайте ваш скрипт в конце страницы
> Помните, что главная цель – сделать загрузку страницы максимально быстрой для пользователя. При загрузке скрипта браузер не может продолжить (* начать выполнение кода), пока не загружен весь файл. Поэтому пользователь должен будет ждать дольше, чтобы заметить какой-либо прогресс (* если скрипт размещается не в конце файла).

> Если у вас имеются файлы JS, единственная цель которых – добавление какой-то функциональной возможности (например, после нажатия кнопки), то вперед, разместите эти файлы внизу, сразу перед закрывающим тегом body. Это безусловно относится к устоявшейся практике.

#### Пример:

``` html
        <p>And now you know my favorite kinds of corn. </p>
        <script type="text/javascript" src="path/to/file.js"></script>
        <script type="text/javascript" src="path/to/anotherFile.js"></script>
    </body>
</html>
```
___

## 2. Уменьшите количество переменных в глобальной области видимости

> «Уменьшая ваш след (* количество переменных) в глобальной области видимости до единственного имени, вы значительно снижаете шансы дурного взаимодействия с другими приложениями, виджетами или библиотеками.»
– Douglas Crockford.

#### ✗ Плохой пример:
``` js
let name = 'Jeffrey';
let lastName = 'Way';

function doSomething() {...};

console.log(name); // Jeffrey -- or window.name
```

#### ✓ Хроший пример

``` js
const DudeNameSpace = {
    name : 'Jeffrey',
    lastName : 'Way',
    doSomething : function() {...}
}
console.log(DudeNameSpace.name); // Jeffrey
```
___

## 3. Комментируйте свой код

> Поначалу может показаться, что в этом нет необходимости, но поверьте мне, вам следует комментировать ваш код насколько это возможно. Что произойдет, когда вы вернетесь к вашему проекту через несколько месяцев, – только то, что вы поймете: не так-то просто вспомнить ход собственной мысли. Или что если одному из ваших коллег необходимо будет внести изменения в ваш код? Всегда, всегда комментируйте важные части вашего кода.

``` js
for(let i = 0, len = array.length; i < len; i++) {
    console.log(array[i]);
};
```
___

## 4. Используйте === вместо ==

> В JavaScript используются два вида операторов равенства: === | !== и == | != . Рекомендуется всегда использовать первый набор при сравнении (* предотвращает ошибки приведения типов. Однако при работе с == и != у вас могут возникнуть ошибки (* приведения типов), если значения имеют различный тип данных. В этих случаях они попробуют преобразовать тип значений, что часто приводит к ошибкам.

+ #### Используя оператор == (Равенство):
``` js
true == 1; //true
"2" == 2; //true
```
+ #### Используя оператор === (Identity)
``` js
true === 1; //false
"2" === 2;  //false
```

> Это связано с тем, что оператор равенства == имеет тип принуждения, что означает, что интерпретатор неявно пытается преобразовать значения перед сравнением. С другой стороны, оператор Identity === не выполняет тип принуждения и, следовательно, не преобразует значения при сравнении.

#### При использовании === для тестирования равенства JavaScript все как есть. Перед оценкой ничего не преобразуется.

![equality](https://overcoder.net/img/1/1/21/2000.png)

#### При использовании == для тестирования равенства JavaScript используются некоторые смешные конверсии.

![identity](https://overcoder.net/img/1/1/21/2001.png)

+ Object всегда соответствует true
+ Undefined всегда соответствует false
+ Null всегда соответствует false
+ Boolean остается неизменным
+ Number соответствует false, если является +0, -0, или NaN, в противном случае соответствует true
+ String означает false, если является пустой строкой '', в противном случае true. +Условно говоря, для строки происходит сравнение не ее самой, а ее длины – в соответствии с типом number.
___

## 5. Объявляйте переменные снаружи от цикла For

> При выполнении длинных циклов «for» не создавайте дополнительной нагрузки на движок.

#### ✗ Плохой пример
``` js
for(let i = 0; i < someArray.length; i++) {
    let container = document.getElementById('container');
    container.innerHtml += 'my number: ' + i;
    console.log(i);
};
```

#### ✓ Хороший пример

``` js
let container = document.getElementById('container');
for(let i = 0, len = someArray.length; i < len;  i++) {
    container.innerHtml += 'my number: ' + i;
    console.log(i);
};
```

> #### Обратите внимание, как нам необходимо определять длину массива при каждой итерации и как мы каждый раз обходим DOM (* объектная модель документа) для получения элемента с id "container" – очень неэффективно!
___

## 6. Избегайте использования eval ()

+ ### Функция eval выполняет строку кода JavaScript в локальной области видимости.

``` js
let foo = 1;
function test() {
    let foo = 2;
    eval('foo = 3');
    return foo;
};
test() // 3
foo // 1
```

+ ### eval исполняется в локальной области видимости только тогда, когда он вызывается напрямую и при этом имя вызываемой функции именно eval.

``` js
let foo = 1;
function test() {
    let foo = 2;
    let bar = eval;
    bar('foo = 3');
    return foo;
};
test() // 2
foo // 3
```

### Любой ценой избегайте использования функции eval. 99.9% случаев её "использования" могут достигаться без её участия.

### Проблемы с безопасностью
Кроме всего прочего, функция eval — это проблема в безопасности, поскольку исполняется любой переданный в неё код; никогда не следует использовать её со строками из неизвестных или недоверенных источников.

> Никогда не стоит использовать eval: любое применение такого кода поднимает вопросы о качестве его работы, производительности и безопасности. Если вдруг для работы вам необходима eval, эта часть должна тут же ставиться под сомнение и не должна использоваться в первую очередь — необходимо найти лучший способ, которому не требуются вызовы eval.
___

## 7. Избегайте использования new Object()

+ ### Имеется множество способов создания объектов в JavaScript. Вероятно, более традиционным способом является использование конструктора «new».

#### ✗ Плохой пример
``` js
let o = new Object();
o.name = 'Jeffrey';
o.lastName = 'Way';
o.someFunction = function() {
console.log(this.name);
 }
```

#### ✓ Хороший пример
``` js
let o = {
    name: 'Jeffrey',
    lastName = 'Way',
    someFunction : function() {
        console.log(this.name);
    }
};
```

+ ### Если вы просто хотите создать пустой объект, использование {} решит проблему. Например:

``` js
let	o = {};
```

#### А так же, помимо {} вместо new Object(), используйте:
+ [] вместо new Array()
+ 0 вместо new Number()
+ false вместо new Boolean()
+ function (){} вместо new Function()
+ /()/ вместо new RegExp()
___

## 8. Ставьте запятые в конце строки

#### ✗ Плохой пример

``` js
const hero = {
    firstName: 'Bob'
  , lastName: 'Parr'
  , heroName: 'Mr. Incredible'
  , superPower: 'strength'
};
```

#### ✓ Хороший пример
``` js
const hero = {
    firstName: 'Bob',
    lastName: 'Parr',
    heroName: 'Mr. Incredible',
    superPower: 'strength'
};
```
___

## 9. Именования
+ ### Избегайте однобуквенных имен функций. Имена должны давать представление о том, что делает эта функция.

#### ✗ Плохой пример
``` js
function q() {
    // ...код...
}
```

#### ✓ Хороший пример
``` js
function query() {
    // ...код...
}
```

+ ### Используйте camelCase для именования объектов, функций и переменных.
#### ✗ Плохой пример
``` js
let OBJEcttsssss = {};
let this_is_my_object = {};
function c() {};
let u = new user({
    name: 'Bob Parr'
});
```

#### ✓ Хороший пример
``` js
let thisIsMyObject = {};
function thisIsMyFunction() {};
let user = new User({
    name: 'Bob Parr'
});
```

+ ### Используйте PascalCase для именования конструкторов классов

#### ✗ Плохой пример
``` js
function user(options) {
    this.name = options.name;
}

let bad = new user({
    name: 'Плохиш'
});
```

#### ✓ Хороший пример
``` js
function User(options) {
    this.name = options.name;
}

let good = new User({
  name: 'Кибальчиш'
});
```

+ ### Используйте подчеркивание _ в качестве префикса для именования внутренних методов и переменных объекта.
#### ✗ Плохой пример
``` js
this.__firstName__ = 'Panda';
this.firstName_ = 'Panda';
```

#### ✓ Хороший пример
``` js
this._firstName = 'Panda';
```

+ ### Создавая ссылку на this, используйте _this.
#### ✗ Плохой пример
``` js
function() {
    let self = this;
    return function() {
        console.log(self);
    };
}

function() {
    let that = this;
    return function() {
        console.log(that);
    };
}
```

#### ✓ Хороший пример
``` js
function() {
    let _this = this;
    return function() {
        console.log(_this);
    };
}
```

+ ### Задавайте имена для функций. Это повышает читаемость сообщений об ошибках кода.
#### ✗ Плохой пример
``` js
const log = function(msg) {
    console.log(msg);
};

```

#### ✓ Хороший пример
``` js
const log = function log(msg) {
  console.log(msg);
};
```
___

## 10. Используйте геттеры и сеттеры для доступа к значениям объекта

+ ### Функции универсального доступа к свойствам не требуются
+ ### Если вам необходимо создать функцию для доступа к переменной, используйте раздельные функции getVal() и setVal('hello')

#### ✗ Плохой пример
``` js
dragon.age();
dragon.age(25);
```

#### ✓ Хороший пример
``` js
dragon.getAge();
dragon.setAge(25);
```

+ ### Если свойство является логическим(boolean), используйте isVal() или hasVal()

#### ✗ Плохой пример
``` js
if (!dragon.age()) {
    return false;
};
```

#### ✓ Хороший пример
``` js
if (!dragon.hasAge()) {
    return false;
};
```

#### Вы можете создавать функции get() и set(), но будьте логичны и последовательны – то есть не добавляйте свойства, которые не могут быть изменены через эти функции.
___